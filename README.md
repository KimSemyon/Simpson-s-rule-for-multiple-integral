# Simpson-s-rule-for-multiple-integral
Распараллеливание(thread) вычислений метода Симпсона для интеграла размерности N.
***
Название файла  | Содержание файла
----------------|----------------------
main.cpp       | Файл метода Симпсона.
main(parallel).cpp       | Файл метода Симпсона с распараллеливанием, используя std::thread.
*замечание(тесты)*      | Переключения между тестовыми функциями производится вручную (пока что). Для преключения между последовательной и параллельной версиями раскомментируйте нужную часть кода. 
***
Запуск: Вставить нужную формулу в функциях Nfunc и NfuncP. Нажать F5 ( in mvs).

Входные данные: N - размерность интеграла, 
                n - (Без ограничения общности работы алгоритма и для простоты его проверки, пределы интегрирования каждой размерности интеграла равны и число точек на каждом сегменте равно 2*n). Введите число n. Чем больше n, тем точнее ответ.
                Пары пределы интегрирования. Например, -10 10 -10 10 и т.д.
                nthreads - количество дополнительных потоков.(в параллельной версии кода)
***
Пример: f(x_i) = x1 + x2 + x3 с пределами интегрирования -100 100;
Входные данные: N = 3; n = (например) 800; пределы интегрирования: -100 100 -100 100 -100 100; nthreads = (например) 2.
***
Примеры функций Nfunc и NfuncP:

 ```
 double Nfunc(int N, double X[]){
//N=3:
//test-1: f(x_i)=x1+x2+x3
	//return (X[0]+X[1]+X[2]);

//test-2: f(x_i)=sin( x1^3 + 2 * x2^2 + 3 * x3)
	//return sin(pow(X[0], 3.0)+2*pow(X[1], 2.0)+3*X[2]);

//test-3: f(x_i)=exp(1+x1-x2-x3)
	//return exp(1+X[0]-X[1]-X[2]);

//test-4: f(x_i)=( x1^2 * x2^2  + x2^2 * x3^2 + x1^2 * x3^2 ) / (x1*x2*x3)
	//return ((pow(X[0], 2.0) * pow(X[1], 2.0) + pow(X[1], 2.0) * pow(X[2], 2.0) + pow(X[0], 2.0) * pow(X[2], 2.0)) / (X[0] * X[1] * X[2]));
}

double NfuncP(int N, double X[], double last_elem){
//N=3:
//test-1: f(x_i)=x1+x2+x3
	//return (X[0]+X[1]+last_elem);

//test-2: f(x_i)=sin( x1^3 + 2 * x2^2 + 3 * x3)
	//return sin(pow(X[0], 3.0)+2*pow(X[1], 2.0)+3*last_elem);

//test-3: f(x_i)=exp(1+x1-x2-x3)
	//return exp(1+X[0]-X[1]-last_elem);

//test-4: f(x_i)=( x1^2 * x2^2  + x2^2 * x3^2 + x1^2 * x3^2 ) / (x1*x2*x3)
	//return ((pow(X[0], 2.0) * pow(X[1], 2.0) + pow(X[1], 2.0) * pow(last_elem, 2.0) + pow(X[0], 2.0) * pow(last_elem, 2.0)) / (X[0] * X[1] * last_elem));
}
```
